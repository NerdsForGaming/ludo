import { createServer } from 'http';
import { parse } from 'url';
import next from 'next';
import { Server } from 'socket.io';
// Room IDs are generated by clients

const dev = process.env.NODE_ENV !== 'production';
const hostname = 'localhost';
const port = parseInt(process.env.PORT, 10) || 3000;

// Initialize Next.js app
const app = next({ dev, hostname, port });
const handle = app.getRequestHandler();

app.prepare().then(() => {
  const httpServer = createServer((req, res) => {
    const parsedUrl = parse(req.url, true);
    handle(req, res, parsedUrl);
  });

  const io = new Server(httpServer, {
    cors: {
      origin: process.env.NODE_ENV === 'production'
        ? ['https://your-domain.vercel.app']
        : ['http://localhost:3000'],
      methods: ['GET', 'POST']
    }
  });

  // Game state management
  const rooms = new Map();

  io.on('connection', (socket) => {
    console.log('Client connected:', socket.id);

    socket.on('join_room', (data) => {
      const { roomId, playerName, playerColor } = data;

      // Join or create room
      if (!rooms.has(roomId)) {
        rooms.set(roomId, {
          id: roomId,
          players: [],
          gameState: null,
          maxPlayers: 4,
          createdAt: Date.now()
        });
      }

      const room = rooms.get(roomId);

      if (room.players.length >= room.maxPlayers) {
        socket.emit('error', { message: 'Room is full' });
        return;
      }

      // Check if color is already taken
      const colorTaken = room.players.some(player => player.color === playerColor);
      if (colorTaken) {
        socket.emit('error', { message: 'Color already taken' });
        return;
      }

      // Create player
      const player = {
        id: socket.id,
        name: playerName,
        color: playerColor,
        pieces: [],
        isActive: false
      };

      // Initialize pieces for the player
      for (let i = 0; i < 4; i++) {
        player.pieces.push({
          id: `${socket.id}-${playerColor}-${i}`,
          color: playerColor,
          position: 'home',
          playerId: socket.id
        });
      }

      room.players.push(player);

      // Join socket room
      socket.join(roomId);

      // If this is the first player, initialize game state
      if (room.players.length === 1) {
        room.gameState = {
          id: roomId,
          players: room.players,
          currentPlayerIndex: 0,
          diceValue: 0,
          isRolling: false,
          winner: null,
          status: 'waiting',
          board: createBoard()
        };
      } else {
        // Update existing game state with new player
        room.gameState.players = room.players;
      }

      // Notify all players in room
      io.to(roomId).emit('player_joined', {
        player,
        gameState: room.gameState
      });

      socket.emit('room_joined', {
        room: room,
        gameState: room.gameState
      });

      console.log(`Player ${playerName} joined room ${roomId}`);
    });

    socket.on('leave_room', (data) => {
      const { roomId } = data;
      const room = rooms.get(roomId);

      if (room) {
        room.players = room.players.filter(player => player.id !== socket.id);
        socket.leave(roomId);

        // If room is empty, delete it
        if (room.players.length === 0) {
          rooms.delete(roomId);
        } else {
          // Update game state
          room.gameState.players = room.players;
          io.to(roomId).emit('player_left', { playerId: socket.id });
        }
      }

      console.log(`Player ${socket.id} left room ${roomId}`);
    });

    socket.on('start_game', (data) => {
      const { roomId } = data;
      const room = rooms.get(roomId);

      if (room && room.players.length >= 2) {
        room.gameState.status = 'playing';
        room.gameState.currentPlayerIndex = 0;
        room.gameState.players[0].isActive = true;

        io.to(roomId).emit('game_started', { gameState: room.gameState });
        console.log(`Game started in room ${roomId}`);
      }
    });

    socket.on('roll_dice', (data) => {
      const { roomId } = data;
      const room = rooms.get(roomId);

      if (!room || room.gameState.status !== 'playing') return;

      const currentPlayer = room.gameState.players[room.gameState.currentPlayerIndex];
      if (currentPlayer.id !== socket.id) return;

      // Roll dice
      const diceValue = Math.floor(Math.random() * 6) + 1;
      room.gameState.diceValue = diceValue;
      room.gameState.isRolling = false;

      io.to(roomId).emit('dice_rolled', {
        diceValue,
        playerId: socket.id,
        gameState: room.gameState
      });

      console.log(`Dice rolled: ${diceValue} in room ${roomId}`);
    });

    socket.on('move_piece', (data) => {
      const { roomId, pieceId, diceValue } = data;
      const room = rooms.get(roomId);

      if (!room || room.gameState.status !== 'playing') return;

      const currentPlayer = room.gameState.players[room.gameState.currentPlayerIndex];
      if (currentPlayer.id !== socket.id) return;

      // Find the piece
      let movedPiece = null;
      for (const player of room.gameState.players) {
        const piece = player.pieces.find(p => p.id === pieceId);
        if (piece) {
          movedPiece = piece;
          break;
        }
      }

      if (!movedPiece) return;

      // Validate move
      if (!canMovePiece(movedPiece, diceValue)) return;

      // Move piece
      const originalPosition = movedPiece.position;
      movedPiece.position = calculateNewPosition(movedPiece, diceValue);

      // Check for captures
      checkCaptures(room.gameState, movedPiece);

      // Move to next player
      room.gameState.currentPlayerIndex = (room.gameState.currentPlayerIndex + 1) % room.gameState.players.length;
      room.gameState.diceValue = 0;

      // Update active player
      room.gameState.players.forEach(player => player.isActive = false);
      room.gameState.players[room.gameState.currentPlayerIndex].isActive = true;

      // Check for winner
      const winner = checkWinner(room.gameState.players);
      if (winner) {
        room.gameState.winner = winner;
        room.gameState.status = 'finished';
        io.to(roomId).emit('game_finished', { winner, gameState: room.gameState });
      } else {
        io.to(roomId).emit('piece_moved', {
          pieceId,
          newPosition: movedPiece.position,
          originalPosition,
          gameState: room.gameState
        });
      }

      console.log(`Piece ${pieceId} moved in room ${roomId}`);
    });

    socket.on('disconnect', () => {
      console.log('Client disconnected:', socket.id);

      // Remove player from all rooms
      for (const [roomId, room] of rooms.entries()) {
        const playerIndex = room.players.findIndex(player => player.id === socket.id);
        if (playerIndex !== -1) {
          room.players.splice(playerIndex, 1);

          if (room.players.length === 0) {
            rooms.delete(roomId);
          } else {
            room.gameState.players = room.players;
            io.to(roomId).emit('player_left', { playerId: socket.id });
          }
        }
      }
    });
  });

  httpServer.listen(port, (err) => {
    if (err) throw err;
    console.log(`> Ready on http://${hostname}:${port}`);
  });
});

// Helper functions (moved from ludo-logic.ts for server compatibility)
function createBoard() {
  const board = [];
  const BOARD_SIZE = 15;

  for (let i = 0; i < BOARD_SIZE; i++) {
    for (let j = 0; j < BOARD_SIZE; j++) {
      board.push({
        id: i * BOARD_SIZE + j,
        x: j,
        y: i,
        type: 'path',
        pieces: []
      });
    }
  }

  return board;
}

function canMovePiece(piece, diceValue) {
  if (piece.position === 'home') return false;
  if (piece.position === 'finish') return false;

  if (piece.position === 'start') {
    return diceValue === 6;
  }

  if (typeof piece.position === 'number') {
    const newPosition = piece.position + diceValue;
    return newPosition <= 56;
  }

  return false;
}

function calculateNewPosition(piece, diceValue) {
  if (piece.position === 'start' && diceValue === 6) {
    return 1;
  }

  if (typeof piece.position === 'number') {
    const newPosition = piece.position + diceValue;
    return newPosition >= 56 ? 'finish' : newPosition;
  }

  return piece.position;
}

function checkCaptures(gameState, movedPiece) {
  // Simple capture logic - remove pieces of other colors from the same position
  gameState.board.forEach(cell => {
    if (cell.pieces.length > 1) {
      const otherPieces = cell.pieces.filter(p => p.color !== movedPiece.color);
      if (otherPieces.length > 0) {
        // Send captured pieces back home
        otherPieces.forEach(piece => {
          piece.position = 'home';
        });
        cell.pieces = cell.pieces.filter(p => p.color === movedPiece.color);
      }
    }
  });
}

function checkWinner(players) {
  for (const player of players) {
    const finishedPieces = player.pieces.filter(piece => piece.position === 'finish').length;
    if (finishedPieces === 4) {
      return player.color;
    }
  }
  return null;
}
